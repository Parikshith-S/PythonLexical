# src/parser.py
"""
A small recursive-descent parser that consumes a list of tokens produced by the lexer.
It builds an AST (Program node from ast_nodes).
Assumptions about token interface:
  token.type : a string or enum-like comparable to names below (e.g., 'INT', 'ID', 'PLUS', ...)
  token.value: original token text
  token.line, token.column: optional for error messages
"""

from typing import List, Optional, Any
from src.ast_nodes import *
from src.token_definitions import Token  # If you have a Token dataclass; otherwise expected interface
# If your project doesn't have token_definitions.Token import, you can omit that import and rely on duck typing.

class ParseError(Exception):
    pass


class Parser:
    def __init__(self, tokens: List[Any]):
        self.tokens = tokens
        self.pos = 0

    # -------------------------
    # Utilities
    # -------------------------
    def peek(self) -> Optional[Any]:
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return None

    def advance(self) -> Optional[Any]:
        tok = self.peek()
        if tok:
            self.pos += 1
        return tok

    def expect(self, expected_type: str) -> Any:
        tok = self.peek()
        if not tok or tok.type != expected_type:
            raise ParseError(f"Expected {expected_type}, got {getattr(tok, 'type', None)} at pos {self.pos}")
        return self.advance()

    def accept(self, expected_type: str) -> Optional[Any]:
        tok = self.peek()
        if tok and tok.type == expected_type:
            return self.advance()
        return None

    # -------------------------
    # Grammar (informal)
    # program     -> { statement }
    # statement   -> var_decl ';'
    #              | assign ';'
    #              | expr ';'
    #              | if_statement
    #              | block
    #              | fun_decl ';'
    # var_decl    -> type ID ('=' expression)?
    # assign      -> ID assign_op expression
    # if_statement-> 'if' expression 'then' statement_list ('else' statement_list)?
    # block       -> '{' { statement } '}'
    # fun_decl    -> 'fun' ID '(' type? ID? ')' '=' expression
    # expression  -> parse with precedence (we implement simple precedence)
    # -------------------------

    def parse(self) -> Program:
        stmts = []
        while self.peek():
            # skip stray semicolons
            if self.accept('SEMI'):
                continue
            stmts.append(self.parse_statement())
        return Program(stmts)

    def parse_statement(self) -> Stmt:
        tok = self.peek()
        if not tok:
            raise ParseError("Unexpected end of input while parsing statement")

        if tok.type in ('INT', 'DOUBLE', 'LONG', 'CHAR', 'BOOL'):
            decl = self.parse_var_decl()
            self.accept('SEMI')
            return decl
        if tok.type == 'FUN':
            fn = self.parse_fun_decl()
            self.accept('SEMI')
            return fn
        if tok.type == 'IF':
            return self.parse_if_statement()
        if tok.type == 'LBRACE':
            return self.parse_block()

        # Could be assignment if next tokens are ID assign_op
        if tok.type == 'ID':
            # lookahead for assignment operator
            next_tok = self.tokens[self.pos + 1] if (self.pos + 1) < len(self.tokens) else None
            if next_tok and next_tok.type in ('ASSIGN', 'PLUSEQ', 'MINUSEQ', 'TIMESEQ', 'DIVEQ'):
                assign = self.parse_assign()
                self.accept('SEMI')
                return assign

        # otherwise expression statement
        expr = self.parse_expression()
        self.accept('SEMI')
        return ExprStmt(expr)

    def parse_var_decl(self) -> VarDecl:
        typ_tok = self.advance()
        typ = typ_tok.value
        id_tok = self.expect('ID')
        name = id_tok.value
        initializer = None
        if self.accept('ASSIGN'):
            initializer = self.parse_expression()
        return VarDecl(typ, name, initializer)

    def parse_assign(self) -> Assign:
        id_tok = self.expect('ID')
        op_tok = self.advance()
        op = op_tok.value
        value = self.parse_expression()
        return Assign(Identifier(id_tok.value), op, value)

    def parse_fun_decl(self) -> FunDecl:
        self.expect('FUN')
        id_tok = self.expect('ID')
        name = id_tok.value
        # optionally accept parameter in form: ( type id )
        self.expect('LPAREN')
        param_type = None
        param_name = None
        if self.peek() and self.peek().type in ('INT', 'DOUBLE', 'LONG', 'CHAR', 'BOOL'):
            param_type = self.advance().value
            if self.peek() and self.peek().type == 'ID':
                param_name = self.advance().value
        self.expect('RPAREN')
        self.expect('ASSIGN')
        body = self.parse_expression()
        return FunDecl(name, param_name, param_type, body)

    def parse_if_statement(self) -> IfStmt:
        self.expect('IF')
        cond = self.parse_expression()
        self.expect('THEN')
        then_branch = []
        # then branch can be a single statement or a block
        if self.peek() and self.peek().type == 'LBRACE':
            then_branch.append(self.parse_block())
        else:
            then_branch.append(self.parse_statement())

        else_branch = None
        if self.accept('ELSE'):
            else_branch = []
            if self.peek() and self.peek().type == 'LBRACE':
                else_branch.append(self.parse_block())
            else:
                else_branch.append(self.parse_statement())

        return IfStmt(cond, then_branch, else_branch)

    def parse_block(self) -> Block:
        self.expect('LBRACE')
        stmts = []
        while self.peek() and self.peek().type != 'RBRACE':
            stmts.append(self.parse_statement())
        self.expect('RBRACE')
        return Block(stmts)

    # -------------------------
    # Expression parsing (precedence climbing / Pratt-like)
    # Operator precedence (highest -> lowest):
    #   unary:  - !
    #   *, /  (note: integer division operator token could be 'INTDIV')
    #   +, -
    #   comparisons: > < == !=
    #   logical: andalso, orelse
    # -------------------------

    def parse_expression(self, min_prec=0):
        tok = self.peek()
        if not tok:
            raise ParseError("Unexpected end of input in expression")

        # prefix / primary
        if tok.type == 'MINUS' or tok.type == 'NOT':
            op = self.advance().value
            rhs = self.parse_expression(100)
            left = UnaryOp(op, rhs)
        elif tok.type == 'LPAREN':
            self.advance()
            left = self.parse_expression()
            self.expect('RPAREN')
        elif tok.type in ('INT_LITERAL', 'DOUBLE_LITERAL'):
            t = self.advance()
            # Convert if you want typed numbers; store raw
            left = NumberLiteral(value=(float(t.value) if t.type=='DOUBLE_LITERAL' else int(t.value.replace('_','').rstrip('lL') if isinstance(t.value,str) else t.value)), raw=t.value)
        elif tok.type == 'CHAR_LITERAL':
            t = self.advance()
            left = CharLiteral(value=t.value.strip('"').strip("'"))
        elif tok.type in ('TRUE', 'FALSE'):
            t = self.advance()
            left = BoolLiteral(value=(t.type == 'TRUE'))
        elif tok.type == 'ID':
            t = self.advance()
            left = Identifier(name=t.value)
        else:
            raise ParseError(f"Unexpected token {tok.type} ({tok.value}) in expression at pos {self.pos}")

        # binary operators loop
        while True:
            next_tok = self.peek()
            if not next_tok:
                break
            prec, assoc = self._op_prec_assoc(next_tok)
            if prec < min_prec:
                break

            op_tok = self.advance()
            op = op_tok.value
            # determine next min precedence (for left/right associativity)
            next_min = prec + (0 if assoc == 'RIGHT' else 1)
            right = self.parse_expression(next_min)
            left = BinaryOp(op, left, right)

        return left

    def _op_prec_assoc(self, tok):
        """
        Return (precedence, associativity) for a token.
        Higher number = higher precedence.
        """
        t = tok.type
        if t in ('TIMES', 'DIVIDE', 'INTDIV'):
            return (60, 'LEFT')
        if t in ('PLUS', 'MINUS'):
            return (50, 'LEFT')
        if t in ('GT', 'LT', 'EQ', 'NEQ'):
            return (40, 'LEFT')
        if t in ('ANDALSO',):
            return (30, 'LEFT')
        if t in ('ORELSE',):
            return (20, 'LEFT')
        # assignment operators are not parsed here as binary expression (they are statements)
        return (0, 'LEFT')
